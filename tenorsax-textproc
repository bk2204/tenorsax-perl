#!/usr/bin/perl

use v5.14;
use strict;
use warnings;

use open qw/:encoding(UTF-8) :std/;
use warnings qw/FATAL utf8/;
use utf8;

use FindBin;
use lib "$FindBin::RealBin/lib";

use Getopt::Long;
use TenorSAX;
use XML::SAX::Writer;
use TenorSAX::App;

my $options = {
	device => 'xml',
	macro => [],
	output => undef,
};
my $p = Getopt::Long::Parser->new();
$p->configure('no_ignore_case', 'bundling');
$p->getoptions($options,
	'device|T=s',
	'format|r=s',
	'macro|m=s@',
	'output|o=s',
);

my $parser;
my $app = TenorSAX::App->new(InputDevice => $options->{format},
	OutputDevice => $options->{device});
for ($options->{format}) {
	when ("pod") {
		require Pod::SAX;
		my $chain = $app->generate_output_chain($options->{output},
			["xml-Pod::SAX"]);
		$parser = Pod::SAX->new(Handler => $chain);
	}
	default {
		die "I don't understand that input format.\n" if $options->{format};
		die "I need an input format.\n";
	}
}

my $data = "";
if (@ARGV) {
	foreach my $file (@ARGV) {
		local $/;
		open(my $fh, '<', $file) or die "Can't open file '$file': $!";
		$data .= <$fh>;
		close($fh) or die "Can't close file '$file': $!";
	}
}
else {
	local $/;
	$data = <STDIN>;
}

$parser->parse_string($data);
