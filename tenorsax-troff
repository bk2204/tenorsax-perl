#!/usr/bin/perl

use v5.14;
use strict;
use warnings;

use open qw/:encoding(UTF-8) :std/;
use warnings qw/FATAL utf8/;
use utf8;

use FindBin;
use lib "$FindBin::RealBin/lib";

use File::Path::Expand;
use Getopt::Long;
use TenorSAX;
use TenorSAX::Source::Troff;
use XML::SAX::Writer;

my $options = {
	device => 'xml',
	macro => [],
	macrodir => [],
	output => undef,
};
my $p = Getopt::Long::Parser->new();
$p->configure('no_ignore_case', 'bundling');
$p->getoptions($options,
	'device|T=s',
	'macro|m=s@',
	'macrodir|M=s@',
	'output|o=s',
);

my %attr = ($options->{output} ? (Output => $options->{output}) : ());
my $output;
my $resolution = 72000;
my @stack;
for ($options->{device}) {
	when ("text") {
		unshift @stack, {
			name => "TenorSAX::Output::Text",
			attributes => \%attr,
		};
	}
	when ("utf8") {
		$resolution = 240;
		unshift @stack, {
			name => "TenorSAX::Output::Terminal",
			attributes => {
				Resolution => $resolution,
				%attr,
			},
		};
	}
	when ("xml") {
		unshift @stack, {
			name => "XML::SAX::Writer",
			attributes => \%attr,
		};
	}
	when ("pdf") {
		unshift @stack, {
			name => "TenorSAX::Output::PDF",
			attributes => \%attr,
		};
	}
	default {
		my $stylesheet;
		my @xslt_dirs = map { File::Path::Expand::expand_filename($_) }
			@{$TenorSAX::Config->{troff}->{xslt}};
		foreach my $dir (reverse @xslt_dirs) {
			$stylesheet = "$dir/format-$options->{device}.xsl";
			last if -r $stylesheet;
			$stylesheet = undef;
		}
		die "Can't load stylesheet for device $options->{device}"
			unless $stylesheet;

		unshift @stack, {
			name => "XML::SAX::Writer",
			attributes => \%attr,
		};
		unshift @stack, {
			name => "XML::Filter::XSLT",
			methods => [
				{
					name => "set_stylesheet_uri",
					args => [$stylesheet],
				}
			],
		};
	}
}
my $logger = sub {};
if ($ENV{TENORSAX_DEBUG}) {
	$logger = sub { say STDERR @_ };
}
my $previous;
foreach my $handler_args (reverse @stack) {
	my $attributes = $handler_args->{attributes} // {};
	my $methods = $handler_args->{methods} // [];
	my $class = $handler_args->{name};
	eval "require $class" or die "Can't load $class: $@";
	my $handler = $class->new(%$attributes,
		($previous ? (Handler => $previous) : ())
	);
	foreach my $method (@$methods) {
		my $args = $method->{args} || [];
		my $func = $handler->can($method->{name}) or
			die "Can't call method $method->{name} on objects of type $class";
		$handler->$func(@$args);
	}
	$previous = $handler;
}

my $parser = TenorSAX::Source::Troff->new(Handler => $previous,
	Resolution => $resolution, Logger => $logger);

my @init_files = map { File::Path::Expand::expand_filename($_) }
	@{$TenorSAX::Config->{troff}->{init_tmac}};

my $data = "";
foreach my $macrodir (@{$options->{macrodir}}) {
	$data .= ".do tenorsax macrodir \"$macrodir\"\n";
}
foreach my $file (@init_files) {
	local $/;
	open(my $fh, '<', $file) or next;
	$data .= ".do tenorsax filename \"$file\"\n";
	$data .= <$fh>;
	close($fh);
}
foreach my $macro (@{$options->{macro}}) {
	$data .= ".do mso \"$macro\"\n";
}
if (@ARGV) {
	foreach my $file (@ARGV) {
		local $/;
		open(my $fh, '<', $file) or die "Can't open file '$file': $!";
		$data .= ".do tenorsax filename \"$file\"\n";
		$data .= <$fh>;
		close($fh) or die "Can't close file '$file': $!";
	}
}
else {
	local $/;
	$data .= <STDIN>;
}

$parser->parse_string($data);
