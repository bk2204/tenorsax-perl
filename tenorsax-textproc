#!/usr/bin/perl

use v5.14;
use strict;
use warnings;

use open qw/:encoding(UTF-8) :std/;
use warnings qw/FATAL utf8/;
use utf8;

use FindBin;
use lib "$FindBin::RealBin/lib";

use Getopt::Long;
use TenorSAX;
use XML::SAX::Writer;
use TenorSAX::Util::HandlerGenerator;

my $options = {
	device => 'xml',
	macro => [],
	output => undef,
};
my $p = Getopt::Long::Parser->new();
$p->configure('no_ignore_case', 'bundling');
$p->getoptions($options,
	'device|T=s',
	'format|r=s',
	'macro|m=s@',
	'output|o=s',
);

my %attr = ($options->{output} ? (Output => $options->{output}) : ());
my $resolution = 72000;
my $raw;
my @stack;

for ($options->{device}) {
	when ("text") {
		unshift @stack, {
			name => "TenorSAX::Output::Text",
			attributes => \%attr,
		};
	}
	when ("utf8") {
		$resolution = 240;
		unshift @stack, {
			name => "TenorSAX::Output::Terminal",
			attributes => {
				Resolution => $resolution,
				%attr
			},
		};
		unshift @stack, tm_to_le($resolution, \%attr);
	}
	when ("xml") {
		$raw = 1;
		unshift @stack, {
			name => "XML::SAX::Writer",
			attributes => \%attr,
		};
	}
	when ("tmxml") {
		unshift @stack, {
			name => "XML::SAX::Writer",
			attributes => \%attr,
		};
	}
	when ("lexml") {
		unshift @stack, {
			name => "XML::SAX::Writer",
			attributes => \%attr,
		};
		unshift @stack, tm_to_le($resolution, \%attr);
	}
	when ("pdf") {
		unshift @stack, {
			name => "TenorSAX::Output::PDF",
			attributes => \%attr,
		};
		unshift @stack, tm_to_le($resolution, \%attr);
	}
	default {
		die "I need an output format.\n" unless $options->{device};

		require File::Path::Expand;

		my $stylesheet;
		my @xslt_dirs = map { File::Path::Expand::expand_filename($_) }
			@{$TenorSAX::Config->{troff}->{xslt}};
		foreach my $dir (reverse @xslt_dirs) {
			$stylesheet = "$dir/format-$options->{device}.xsl";
			last if -r $stylesheet;
			$stylesheet = undef;
		}
		die "Can't load stylesheet for device $options->{device}"
			unless $stylesheet;

		unshift @stack, {
			name => "XML::SAX::Writer",
			attributes => \%attr,
		};
		unshift @stack, {
			name => "XML::Filter::XSLT",
			methods => [
				{
					name => "set_stylesheet_uri",
					args => [$stylesheet],
				}
			],
		};
	}
}

my $parser;
my $generator = TenorSAX::Util::HandlerGenerator->new;
for ($options->{format}) {
	when ("pod") {
		require Pod::SAX;
		unless ($raw) {
			unshift @stack, {
				name => "TenorSAX::Filter::PodSAXToTextMarkup",
			};
		}
		$parser = Pod::SAX->new(Handler => $generator->generate(@stack));
	}
	default {
		die "I don't understand that input format.\n" if $options->{format};
		die "I need an input format.\n";
	}
}

my $data = "";
if (@ARGV) {
	foreach my $file (@ARGV) {
		local $/;
		open(my $fh, '<', $file) or die "Can't open file '$file': $!";
		$data .= <$fh>;
		close($fh) or die "Can't close file '$file': $!";
	}
}
else {
	local $/;
	$data = <STDIN>;
}

$parser->parse_string($data);

sub tm_to_le {
	my ($resolution, $args) = @_;

	return {
		name => "TenorSAX::Filter::TextMarkupToLayoutEngine",
		attributes => {
			Resolution => $resolution,
			%$args
		},
	};
}
