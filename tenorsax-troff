#!/usr/bin/perl

use v5.14;
use strict;
use warnings;

use open qw/:encoding(UTF-8) :std/;
use warnings qw/FATAL utf8/;
use utf8;

use Getopt::Long;
use TenorSAX::Source::Troff;
use XML::SAX::Writer;

my $options = {
	device => 'xml',
};
my $p = Getopt::Long::Parser->new();
$p->configure('no_ignore_case', 'bundling');
$p->getoptions($options,
	'device|T=s'
);

my $output;
my $resolution = 72000;
given ($options->{device}) {
	when (/^text$/) {
		require TenorSAX::Output::Text;
		$output = TenorSAX::Output::Text->new();
	}
	when (/^utf8/) {
		require TenorSAX::Output::Terminal;
		$resolution = 240;
		$output = TenorSAX::Output::Terminal->new(Resolution => $resolution);
	}
	default {
		require XML::SAX::Writer;
		$output = XML::SAX::Writer->new();
	}
}
my $parser = TenorSAX::Source::Troff->new(Handler => $output,
	Resolution => $resolution);

my @init_files = (
	"/usr/share/tenorsax/tmac/init.tmac",
	"/usr/local/share/tenorsax/tmac/init.tmac",
	"/etc/tenorsax/tmac/init.tmac",
	"$ENV{HOME}/.config/tenorsax/tmac/init.tmac"
);

my $data = "";
foreach my $file (@init_files) {
	local $/;
	open(my $fh, '<', $file) or next;
	$data .= ".do tenorsax filename \"$file\"\n";
	$data .= <$fh>;
	close($fh);
}
if (@ARGV) {
	foreach my $file (@ARGV) {
		local $/;
		open(my $fh, '<', $file) or die "Can't open file '$file': $!";
		$data .= ".do tenorsax filename \"$file\"\n";
		$data .= <$fh>;
		close($fh) or die "Can't close file '$file': $!";
	}
}
else {
	local $/;
	$data .= <STDIN>;
}

$parser->parse_string($data);
